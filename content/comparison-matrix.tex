\section{Comparison Matrices}\label{sec:matrix}

\vspace*{-0.2cm}


In this paper, we propose three matrices to assist the architect in selecting the right technologies for his use-case. To achieve this, we classify technologies to build Semantic REST systems along criteria that are categorized by the levels of WS3. As explained in the previous section, the WS3 classification is too coarse-grained to grasp all important differences between systems of the same maturity level. We propose the following matrices to compare the technologies along a set of precise criteria to highlight these differences. Some presented criteria cannot be linked to one level of WS3 but remain useful in practice. We decided to keep them in an "other" category.

\subsection{Comparison Matrices Design Methodology}

% TODO - IN PROGRESS - From reviewer 2 : My impression is that the paper only accounts the result of the web search, and developers' expertise is not actually leveraged. Which are the daily problems developers face? Go deeper with their experience. The framework is intended to be used by developers, you should take into account their insights from the trenches. Interview people from your company if needed, and provide links to their responses/questionnaires.

The design of our comparison matrices follows a 5 steps sequential process: \textit{(i)} \textbf{search} for candidate technologies, \textit{(ii)} \textbf{select} candidate technologies, \textit{(iii)} \textbf{read} carefully each candidate technology, \textit{(iv)} \textbf{elaborate fine grain criteria} to characterize and differentiate technologies, \textit{(v)} \textbf{verification} that the elaborated criteria highlighted the differences between technologies. Several steps of refinement were needed to avoid duplicating criteria or hiding important details, by looping on step \textit{(iv)} and \textit{(v)}.

The research of candidate technologies (step i) was done by:

\begin{enumerate}
    \item Searching Google and Google Scholar for Semantic REST Technologies using compositions of keywords from the set: ["web", "semantic", "restful", "rest", "service", "API", "interface", "description", "documentation", "language", "modeling", "hypermedia", "document", "format", "RDF", "data-interchange", "linked data", "hateoas", "rest api", "framework"];
    \item Searching Google Scholar for tools automating tasks from services description, using keywords: "matchmakers", "service composition", "service discovery", "rest service analysis", "automated mashups", we then selected other papers and technologies from their references and the papers that cite those we selected;
    \item Searching the proceedings of ICWE and WS-REST. 
\end{enumerate}

% Maybe update the 81 number below if the Github with raw material changes.
We selected 81 papers, standards, articles and web pages (step ii) from their abstract or introduction. We selected documents that were the specification of an interface definition language or model, a framework that supports HATEOAS features, an interchange format that supports RDF or HATEOAS features, a comparison between these technologies or a tool leveraging them. Frameworks to build Semantic Web Services were excluded because they are based on triples which are too far from the resource-oriented design of REST. We opened our research to technologies from the 1990s to today and retained technologies that are still available today.

As a next step, we read the specification of each chosen technology (step iii) and elaborate classification criteria (step iv). We included those of the H~Factor~\footnote{\url{http://amundsen.com/hypermedia/hfactor/}} which \textit{is a measurement of the level of hypermedia support and sophistication of a media-type}. Others were carefully designed to highlight differences between technologies in the area of Semantic REST, based on the core design of the technologies, the features they provide and the details of the WS3 maturity model. All the raw material to elaborate this classification is available online\footnote{\url{https://github.com/AntoineCheron/semantic-restful-api-technologies-comparison-matrix}}.

As a final step (step v), we read the specifications again to verify results and validate that the selected criteria highlighted differences and commonalities well.

\paragraph{Popularity criteria}

We included a popularity criteria to provide a rough idea of the community support and the likelihood of the technology to last in time. The popularity score is between 0 and 2. It respects the following rules: 
\begin{inparadesc}
    \item [0 -] Not enough to reach 1;
    \item [1 -] More than 100 questions on stack overflow AND (2500+ NPM weekly downloads OR 100+ maven usages);
    \item [2 -] More than 400 questions on stack overflow AND (more than 500.000 total downloads OR more than 15.000 NPM weekly downloads OR more than 500 maven usages).
\end{inparadesc}

\subsection{Interface Description Languages}

Interface Description Languages (IDLs) provide a vocabulary to document domain, functional and non-functional aspects of an API.
We identified 16 candidates that are classified according to 31 criteria in Fig~\ref{idl-matrix}. Among them, 4 are meta-models from conference papers \cite{10.1109/ICWS.2014.30} \cite{Rapido} \cite{Schreier:2011:MRA:1967428.1967434} \cite{10.1007/978-3-642-22233-7_24}. The 11 others are open-source projects or W3C recommendations.

In \cite{Rapido} authors present a tool to sketch CRUD or Hypermedia APIs. On the latter mode, users sketch the application using state-machines and then obtain a description in the HAL or Collection+JSON format.
\cite{Schreier:2011:MRA:1967428.1967434} models each resource type as a finite-state-machine with deterministic transitions, and conditions to inform about the availability of transition. However, they are not modeled in more details, which do not make them machine-interpretable.
In~\cite{10.1007/978-3-642-22233-7_24}, authors propose to model the system as a non-deterministic state machine. This method thus makes software agents unable to discover the set of messages to exchange in order to make an operation available.
Haupt et al.~\cite{10.1109/ICWS.2014.30} propose a thorough multi-layered model that separates the domain model from the URI model. However, resources have a fixed model, which does not allow them to have a data model adapted to each state.

It is important to note than when \textbf{IDLs and interchange formats} are both \textbf{compatible with RDF}, they can be combined to form a file format usable as data-interchange format and IDL. This has great benefits to lower the overall complexity and increase the evolvability of the system.

% FIGURE OF THE IDL CLASSIFICATION
\begin{figure*}[!ht]
\caption{Interface Description Languages Comparison Matrix}
\includegraphics[width=1\textwidth]{figures/IDL.png}
\label{idl-matrix}
\end{figure*}

\subsubsection*{Synthesis}

First, the matrix highlights the fact that most technologies help building mature systems on the \textit{design} dimension and \textit{interaction profile} level of the \textit{profile} dimension, D3-P1 following the WS3 categories.
On the other hand on the \textit{semantic} dimension, we notice that 5/16 technologies support the use of RDF vocabulary, which allows to build Linked Data APIs. As a reminder, this is required to reach full Semantic REST compliance.
Moreover, by supporting the use of RDF vocabulary, IDLs can be enriched to reach a higher level of maturity.

Among the technologies, four can be distinguished by the number of criteria they meet: Hydra (18), RADL (18), OpenAPI (17) and RESTdesc (17).
OpenAPI is the only one that has no support for RDF. Thus, it helps in building systems up to D3-P2-S0 on the WS3 scale.
On the other hand, Hydra, RADL and RESTdesc support the use of RDF vocabulary, which makes these technologies better suited to build systems that are mature on the semantic dimension.

\paragraph{Towards HATEOAS APIs}
From the matrix, we notice that most technologies target the documentation of the API in a single, non-splittable file. Hence, they are not suited to provide hypermedia controls at runtime.

On the other hand, only one approach, \cite{Schreier:2011:MRA:1967428.1967434}, supports the description of the conditions that determine the availability of a link, and none makes this meta-data machine-interpretable. This makes software agents unable to find a way to make an operation available when it is not.

\paragraph{Towards better-documented APIs}
Only four technologies support the description of business constraints although it lowers coupling and improves user experience. For example with the automatic generation of forms with client-side validation.

% OLIVIER : DO NOT REMOVE, THIS IS BECAUSE THE PARAGRAPH IS ABOUT SOMETHING ELSE THAN THE ABOVE
\paragraph{}
Finally, we note that most scientific publications recommend the modeling of RESTful systems as state-machines whereas open-sourced or W3C IDL authors don't consider this design method. And yet, the use of deterministic state-machines eases determining the availability of operations on a resource.

\subsection{Data-interchange formats}

Data-interchange formats provide a data-structure, a vocabulary and a layout to represent a resource and its meta-data at runtime. When the goal is not to provide meta-data, JSON, XML and YAML are the three formats widely used in the industry.

On the other side, when the system to build have to support a hypermedia interchange format, none is considered as a standard today. We selected 11 candidate technologies, which are classified in Fig.~\ref{interchange-formats-matrix} according to 24 criteria. JSON is included for comparison purpose.

% FIGURE OF THE INTERCHANGE FORMATS CLASSIFICATION
\begin{figure*}[!ht]
\caption{Data-interchange Formats Comparison Matrix}
\includegraphics[width=1\textwidth]{figures/DIF.png}
\label{interchange-formats-matrix}
\end{figure*}

\subsubsection*{Synthesis}
First, from this matrix, we notice that formats can be differentiated based on their compatibility with RDF. Indeed, RDF formats (Turtle, RDF XML and JSON-LD) can be enriched with RDF vocabularies. This is why they propose very few features by default. To depict what is possible to achieve by combining vocabularies with a RDF format, we selected two vocabularies: Hydra and SHACL, an RDF schema validation vocabulary, that we combined with JSON-LD and evaluated it. As a result, it matches 12 more criteria than JSON-LD alone.
From this, we infer that combining RDF formats with vocabularies allow building mature Semantic REST systems. However, this requires additional effort to find relevant vocabularies.
On the other hand, non-RDF formats help building systems that can be mature on the \textit{profile} dimension but not on the \textit{semantic} dimension.

Furthermore, the matrix shows that no format supports the description of constraints despite the fact that it can be leveraged to reduce coupling and improve the user-experience.

Finally, it highlights that no format advertise the state of the resource even though most scientific approaches we found describe REST APIs as state-machines.

\subsection{Implementation Frameworks}

Implementation frameworks are software libraries that guide developers through the implementation of Web APIs. We limit the comparison to frameworks that claim to support HATEOAS. We identified six frameworks that do so. Frameworks to build Semantic Web Services are excluded because their triple-centric approach is too far from REST.

Among selected papers, in \cite{salvadori2014framework} authors propose \textit{Hypermedia Web API Support}, a Java framework based on JAX-RS 2.0 that offers annotations to semantically describe REST APIs. The end result is the description of the whole API in a JSON-LD document enriched with the Hydra vocabulary. Unfortunately, the framework is not available in Maven Central. In \cite{parastatidis2010role} Parastatidis et al. present \textit{Restfulie}, a framework that uses resources, state transitions and content-negotiation as its core building blocks. We found 4 other frameworks that support HATEOAS features. They are all classified in Fig.~\ref{frameworks-matrix} according to 23 criteria.

% FIGURE OF THE IMPLEMENTATION FRAMEWORKS CLASSIFICATION
\begin{figure*}[!ht]
\caption{Implementation Frameworks Comparison Matrix}
\includegraphics[width=1\textwidth]{figures/frameworks.png}
\label{frameworks-matrix}
\end{figure*}

\subsubsection*{Synthesis}
Despite the fact that only one framework enforces the \textit{Atomic Resources} constraint, all frameworks allow to reach the highest level of maturity on the \textit{design} dimension easily. This is because supporting the \textit{Atomic Resources} constraint only requires developers to use the data model of the resource as the input of write operations and as the output of read operations.

We notice that only \textit{API Platform} and \textit{Restfulie} offer a mechanism to model relations between resources from which links are automatically generated, instead of adding them programmatically in the response, thus increasing maintainability.

Otherwise, most frameworks do not ease the the semantic neither the domain description of the API. To us, this is the biggest challenge framework designers should tackle today.

Last, as for IDLs, most creators of frameworks do not provide mechanisms to describe resources as state machines, thus not taking advantage of its benefits.
